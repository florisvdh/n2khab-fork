% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/datawrangling.R
\name{expand_types}
\alias{expand_types}
\title{Expand a 'type' column in a dataframe}
\usage{
expand_types(x, type_var = "type", use_grouping = TRUE, strict = TRUE)
}
\arguments{
\item{x}{An object of class \code{data.frame}.}

\item{type_var}{A string.
The name of the dataframe variable that holds the type codes.
Defaults to \code{type}.}

\item{use_grouping}{Logical.
If the dataframe has one or more grouping variables
(class \code{grouped_df}),
is the operation to be performed independently
for each group in turn?}

\item{strict}{Logical.
Apply conditions before expanding subtype codes to main type codes?}
}
\value{
A dataframe, either identical or longer than the input dataframe.
}
\description{
Takes a dataframe with a column of type codes
(\emph{main type} or \emph{subtype }codes),
and, under certain conditions, adds new rows with codes of the associated
\emph{subtypes} and \emph{main types}, respectively.
It allows to do sensible selections and joins with interpreted forms of the
\code{habitatmap_stdized} and \code{watersurfaces_hab} data sources:
\code{habitatmap_terr},
\code{read_watersurfaces_hab(interpreted = TRUE)}.
If the dataframe has one or more grouping variables, by default the
operation is done independently for each group in turn.
}
\details{
The extra rows in the dataframe take the values for other variables
from the rows with which they are associated, based on the
subtype - main type relation.
Type codes in the dataframe are verified to comply with the codes from the
\code{\link{types}} data source.
A warning is given when they don't.

Main type codes are always expanded with the subtype codes that belong to it.

The applied approach to add main type codes only makes sense
assuming that the result is to be confronted
with one of the \emph{above listed} geospatial data sources.

In order to add main type codes based on
subtype codes that are present in the type column, specific conditions have
to be met:
\itemize{
\item{for 2330: both subtype codes must be present}
\item{for 5130: 5130_hei must be present (note that only the main type code
occurs in the targeted data sources)}
\item{for 6230: 6230_ha, 6230_hmo and 6230_hnk must be present
(not the rare 6230_hnk)}
\item{for 91E0: 91E0_va, 91E0_vm and 91E0_vn must be present
(not the rarer 91E0_sf, 91E0_vc and 91E0_vo)}
}
However, it is possible to relax this requirement by setting
\code{strict = FALSE}.
This will add the main type code whenever \emph{one} corresponding subtype
code is present.
In all cases no other main type codes are added apart from
2330, 5130, 6230 and 91E0.
This is because the data sources with which the result
is to be matched (see Description) don't contain certain main type codes,
and because it makes no sense in other cases
(rbbkam, rbbvos, rbbzil & 9120 in the \code{habitatmap} do not refer to a
main type but to an non-defined subtype with no specific code).
}
\examples{
library(dplyr)
x <-
    read_scheme_types() \%>\%
    filter(scheme == "GW_05.1_terr")
expand_types(x)
expand_types(x, strict = FALSE)

x <-
    read_scheme_types() \%>\%
    filter(scheme == "GW_05.1_terr") \%>\%
    group_by(typegroup)
expand_types(x)
expand_types(x, use_grouping = FALSE) # equals above example

x <-
    tribble(
        ~mycode, ~obs,
        "2130", 5,
        "2190", 45,
        "2330_bu", 8,
        "2330_dw", 8,
        "5130_hei", 7,
        "6410_mo", 78,
        "6410_ve", 4,
        "91E0_vn", 10
    )
expand_types(x, type_var = "mycode")
expand_types(x, type_var = "mycode", strict = FALSE)

}
\seealso{
\code{\link{read_scheme_types}},
\code{\link{read_types}},
\code{\link{read_habitatmap_terr}},
\code{\link{read_watersurfaces_hab}}
}
